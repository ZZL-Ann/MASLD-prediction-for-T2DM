# Imputing Missing Values (Using the Training Dataset data_train as an Example)
# Load the necessary packages
library(mice)           # Load the mice library for multiple imputation of missing data
library(dplyr)
library(randomForest)   # Data manipulation

# Load the dataset
data_train <- read.csv("C:/Users/Desktop/R data/data_train.csv") # Read the dataset from the specified file path

colSums(is.na(data_train))# Check for missing values

# Specifying Interpolation Methods for Different Variables
meth <- mice::make.method(data_train) # This will return a vector, with each variable corresponding to a default interpolation method.
meth[numVars] <- "rf" # All numerical variables were imputed using the random forest method.
meth[catVars] <- "logreg" # Binary variables use binary logistic regression.
meth["MedStatus"] <- "polyreg" # Three-category variable (medication status) using multinomial logistic regression for imputation

# Perform multiple imputation
imp <- mice(dataAll,seed = 12345, print = FALSE, m = 5, method = meth)
colSums(is.na(complete(imp, 1))) # Check for missing values after interpolation

# Obtain the final interpolated dataset
# Define a function that calculates the interpolated mean of a continuous variable five times based on the corresponding sample ID (which has been de-identified), and the mode for a categorical variable.
# 1. Extract interpolated data (remove rows where .imp = 0 (raw data))
original_data <- data_train
imp_data <- complete(imp, "long", include = TRUE)
imp_data_filtered <- imp_data %>%
  filter(.imp != 0)  
# 2. Calculate the mean value of each variable at the same ID (numeric variables)
numeric_imputed_values <- imp_data_filtered %>%
  group_by(ID) %>%  
  summarise(across(where(is.numeric), ~mean(., na.rm = TRUE)), .groups = "drop")
# 3. Compute the mode of each variable at the same id (for categorical variables)
factor_imputed_values <- imp_data_filtered %>%
  group_by(ID) %>%
  summarise(across(where(is.factor), ~names(sort(table(.), decreasing = TRUE))[1]), .groups = "drop")
# 4.Merge the interpolation results for numerical and categorical variables
imputed_values <- left_join(numeric_imputed_values, factor_imputed_values, by = "ID")
filled_data <- original_data %>% 
  left_join(imputed_values, by = "ID") %>%  # Match by .id; .x and .y are column name suffixes automatically generated by left_join() for duplicate column names
  mutate(across(ends_with(".x"), 
                ~ coalesce(. , get(sub(".x", ".y", cur_column()))), # For each value in the .x column, if the value is NA, fill it with the corresponding value from the .y column
                .names = "{.col}")) %>%  # Retain the .x suffix during the coalesce process
  select(-ends_with(".y")) %>%  # Delete columns with the `.y` suffix
  rename_with(~ sub("\\.x$", "", .), ends_with(".x"))  

filled_data <- filled_data %>%select(-.imp, -.id) # Remove Extra Columns
filled_data[catVars] <- lapply(filled_data[catVars],factor)

# Save the interpolated dataset
write.csv(filled_data,"Interpolated training set data.csv",row.names = FALSE)

